#' @title Predict New Data Using an OPLS Model
#'
#' @description
#' Generates predictions (scores and outcome estimates) using an existing OPLS model fitted with `opls()`. Supports regression and 2-class discriminant analysis.
#'
#' @param opls_model An object of class \code{OPLS_metabom8}, generated by the \code{opls()} function.
#' @param newdata A numeric matrix or data.frame. Each row is a new observation and columns must match those used in the model.
#' @param idx_scale Optional integer vector. Row indices of `newdata` used to compute new centering/scaling parameters. If \code{NULL}, model parameters are reused.
#'
#' @return A named list with the following elements:
#' \describe{
#'   \item{Y_predicted}{Predicted numeric or class outcomes (depending on model type).}
#'   \item{t_pred}{Predicted scores for the predictive component(s).}
#'   \item{t_orth}{Scores for orthogonal components (uncorrelated variation).}
#'   \item{t_orth_pca}{Optional: scores of the first principal component of orthogonal scores (if >1 orthogonal component).}
#' }
#'
#' @details
#' Class predictions are based on the closest numeric projection from the training labels and are not corrected for class imbalance.
#' If more than one orthogonal component is present, the PCA of orthogonal scores is computed to summarise variation orthogonal to Y.
#'
#' @references
#' Trygg J. and Wold S. (2002). Orthogonal projections to latent structures (O-PLS). \emph{Journal of Chemometrics}, 16(3), 119–128.
#' Geladi P. and Kowalski B.R. (1986). Partial least squares and regression: a tutorial. \emph{Analytica Chimica Acta}, 185, 1–17.
#'
#' @seealso \code{\link{opls}}, \code{\link{pca}}, \code{\link{plotscores}}
#' @examples
#' data(covid)
#' X <- covid$X
#' an <- covid$an
#'
#' model <- opls(X, Y = an$type)
#' preds <- predict_opls(model, X)
#' table(preds$Y_predicted, an$type)
#'
#' @export
predict_opls <- function(opls_model, newdata, idx_scale = NULL) {

  if (!inherits(opls_model, "OPLS_metabom8")) {
    stop("Input model must be of class 'OPLS_metabom8'.")
  }

  if (opls_model@type == "DA" && length(unique(opls_model@Y$ori)) != 2) {
    stop("Only two-class discriminant analysis or regression models are supported.")
  }

  X <- if (is.null(ncol(newdata))) rbind(newdata) else as.matrix(newdata)

  if (length(opls_model@X_mean) != ncol(X)) {
    stop("New data does not match training data in number of features.")
  }

  # Scaling
  if (!is.null(idx_scale)) {
    scale_map <- c(none = 0L, UV = 1L)
    scale_type <- scale_map[match(opls_model@Parameters$scale, names(scale_map))]
    sc_res <- .scaleMatRcpp(X, idx_scale - 1L,
                            center = opls_model@Parameters$center,
                            scale_type = scale_type)
    X <- sc_res$X_prep
  } else {
    X <- sweep(X, 2, opls_model@X_mean, FUN = "-")
    X <- sweep(X, 2, opls_model@X_sd, FUN = "/")
  }

  # Remove orthogonal variation
  e_new_orth <- X
  n_pcOorth <- opls_model@nPC - 1
  t_orth <- matrix(NA, nrow = nrow(X), ncol = n_pcOorth)

  for (i in seq_len(n_pcOorth)) {
    w <- t(opls_model@w_orth[i, , drop = FALSE])
    p <- opls_model@p_orth[i, ]
    t_orth[, i] <- e_new_orth %*% w / drop(crossprod(w))
    e_new_orth <- e_new_orth - t_orth[, i] %*% t(p)
  }

  t_orth_pca <- if (n_pcOorth > 1) {
    pc_orth <- pca(t_orth, pc = 1, scale = "UV")
    pc_orth@t[, 1]
  } else {
    NULL
  }

  # Predict using model
  t_pred <- e_new_orth %*% opls_model@w_pred
  betas <- opls_model@betas_pred
  q_h <- opls_model@Qpc
  res <- matrix(NA, nrow = nrow(X), ncol = ncol(opls_model@t_pred))

  for (i in seq_len(ncol(opls_model@t_pred))) {
    res[, i] <- t_pred[, i] * betas[i] * q_h[, i]
  }

  totalPrediction <- rowSums(res)
  Y_predicted <- (totalPrediction * opls_model@Y_sd) + opls_model@Y_mean

  if (opls_model@type == "DA") {
    cs <- table(opls_model@Y$ori, opls_model@Y$dummy)
    levs <- data.frame(Original = rownames(cs),
                       Numeric = as.numeric(colnames(cs)),
                       stringsAsFactors = FALSE)
    Y_predicted <- levs$Original[apply(abs(outer(Y_predicted, levs$Numeric, "-")), 1, which.min)]
  }

  return(list(
    Y_predicted = Y_predicted,
    t_pred = t_pred,
    t_orth = t_orth,
    t_orth_pca = t_orth_pca
  ))
}
